Написать скрипт, который будет бесконечно пинговать указанный адрес (переменная или ввод пользователя) с интервалом 1 секунда между попытками. Если время пинга превышает 100 мс или не удается выполнить пинг в течение 3 последовательных отправок пакетов, скрипт просто выведет сообщения об этом. 
Пришлите скрипт или ссылку на github репо с решением


#!/bin/bash
# ping_watch.sh
# Бесконечно пингуем хост/адрес с интервалом 1s
# Если time > 100 ms -> выводим сообщение
# Если 3 подряд неудачных ответa -> выводим сообщение
#
# Использование:
# ./ping_watch.sh example.com
# или запустить без аргумента — скрипт попросит ввести хост.

set -u

# Получение хоста: из аргумента или от пользователя
if [ $# -ge 1 ]; then
    HOST="$1"
else
    read -r -p "Введите хост или IP для пинга: " HOST
fi

if [ -z "$HOST" ]; then
    echo "Хост не указан. Выход."
    exit 1
fi

# Параметры
TIME_LIMIT_MS=100       # порог RTT в миллисекундах
MAX_CONSECUTIVE_FAIL=3  # порог подряд неудачных пингов
SLEEP_INTERVAL=1        # интервал между попытками в секундах

fail_count=0

echo "Начинаю пинговать: $HOST (интервал ${SLEEP_INTERVAL}s). Порог RTT = ${TIME_LIMIT_MS} ms, порог неудач = ${MAX_CONSECUTIVE_FAIL}."

# Функция: выполнить одиночный ping и вернуть время в ms (число) или пустую строку при отсутствии ответа
get_ping_time_ms() {
    local host="$1"
    # Выполняем один пакет, таймаут ожидания 1 секунда (Linux iputils: -W задаёт timeout в секундах)
    # Команда выдаёт строку вроде: "64 bytes from 93.184.216.34: icmp_seq=1 ttl=56 time=12.3 ms"
    # Если нет ответа — output будет пуст и ping вернёт ненулевой код.
    local out
    out=$(ping -c 1 -W 1 "$host" 2>/dev/null)
    # Ищем поле time= и извлекаем число (в миллисекундах)
    # awk делит по "time=" и затем берёт первое слово после него (например "12.345")
    local t
    t=$(printf "%s\n" "$out" | awk -F'time=' '/time=/{print $2; exit}' | awk '{print $1}')
    # t может быть пустым если нет ответа
    printf "%s" "$t"
}

while true; do
    t_ms=$(get_ping_time_ms "$HOST")

    if [ -n "$t_ms" ]; then
        # Успешный ответ — сбрасываем счётчик неудач
        fail_count=0

        # Убедимся, что t_ms — число (удаляем возможные запятые)
        # Приведём запятую к точке на случай локализации
        t_ms="${t_ms/,/.}"

        # Сравнение чисел: bash не справляется с float, поэтому используем awk для сравнения
        is_gt=$(awk -v val="$t_ms" -v lim="$TIME_LIMIT_MS" 'BEGIN{ if (val+0 > lim+0) print 1; else print 0 }')

        if [ "$is_gt" -eq 1 ]; then
            printf "%s — RTT = %s ms  ==> ВНИМАНИЕ: > %s ms\n" "$(date +'%H:%M:%S')" "$t_ms" "$TIME_LIMIT_MS"
        else
            printf "%s — RTT = %s ms\n" "$(date +'%H:%M:%S')" "$t_ms"
        fi
    else
        # Нет ответа
        fail_count=$((fail_count + 1))
        printf "%s — Пинг не удался (без ответа). Подряд неудач: %d\n" "$(date +'%H:%M:%S')" "$fail_count"

        if [ "$fail_count" -ge "$MAX_CONSECUTIVE_FAIL" ]; then
            echo "$(date +'%H:%M:%S') — ВНИМАНИЕ: $fail_count подряд не получено ответа от $HOST."
            # не обнуляем — если хочешь обнулять после сообщения, раскомментируй следующую строку:
            # fail_count=0
        fi
    fi

    sleep "$SLEEP_INTERVAL"
done